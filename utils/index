#!/bin/sh

if test $# -lt 2; then
    echo "Usage: $0 <elixir_data_path> <project_name> [<repo_urls>...]"
    echo "Usage: $0 <elixir_data_path> --all"
    exit 1
fi

# $1 is the project path (inside will be created data/ and repo/).
# It supports being called on an existing project.
project_init() {
    # Detect already inited projects. Avoids stderr logs.
    # Using `git tag -n1` because `git status` doesn't work on bare repos.
    if git -C $1/repo tag -n1 >/dev/null 2>/dev/null; then
        return;
    fi

    mkdir -p $1/data $1/repo

    git -C $1/repo -c init.defaultBranch=main init --bare

    git config --system --add safe.directory $1/repo
}

# $1 is the project path (parent of data/ and repo/).
# $2 is the remote URL.
project_add_remote() {
    git="git -C $1/repo"

    # Do nothing if remote already exists.
    if $git remote | xargs -L1 -r $git remote get-url 2>/dev/null | grep -qxF "$2"; then
        return;
    fi

    # Remotes are called remote$i with $i = 0, 1, 2...
    i="$($git remote | awk '
        BEGIN { n=-1; }
        $0 ~ /^remote[0-9]+$/ { i=substr($0, length("remote")+1);
                                if (i>n) n=i; }
        END { print n+1; }')"

    $git remote add remote$i "$2"
}

# $1 is the project path (parent of data/ and repo/).
project_fetch() {
    git -C $1/repo fetch --all --tags -j4
}

# $1 is the project path (parent of data/ and repo/).
project_index() {
    if test -z "$ELIXIR_THREADS"; then
        ELIXIR_THREADS="$(nproc)"
    fi

    LXR_REPO_DIR=$1/repo LXR_DATA_DIR=$1/data \
        python3 /usr/local/elixir/update.py $ELIXIR_THREADS
}

# $1 is the Elixir root data path.
# $2 is the project name.
# $... are the remote URLs.
add_remotes() {
    dir="$1/$2"

    project_init "$dir"

    shift
    shift
    for remote
    do
        project_add_remote "$dir" "$remote"
    done
}

do_index() {
    if test ! "$(find $1/data -type f)"; then
        # If we are indexing from scratch, do it twice as the initial one
        # probably took a lot of time.
        project_fetch "$1"
        project_index "$1"
        project_fetch "$1"
        project_index "$1"
    else
        project_fetch "$1"
        project_index "$1"
    fi
}

# Index a single project
if test "$2" != "--all"; then
    dir="$1/$2"
    add_remotes "$@"
    do_index "$dir"
    exit
fi

# Add all known projects remotes
add_remotes $1 amazon-freertos https://github.com/aws/amazon-freertos.git
add_remotes $1 arm-trusted-firmware https://github.com/ARM-software/arm-trusted-firmware
add_remotes $1 barebox https://git.pengutronix.de/git/barebox
add_remotes $1 busybox https://git.busybox.net/busybox
add_remotes $1 coreboot https://review.coreboot.org/coreboot.git
add_remotes $1 dpdk https://dpdk.org/git/dpdk \
                    https://dpdk.org/git/dpdk-stable
add_remotes $1 glibc https://sourceware.org/git/glibc.git
add_remotes $1 llvm https://github.com/llvm/llvm-project.git
add_remotes $1 mesa https://gitlab.freedesktop.org/mesa/mesa.git
add_remotes $1 musl https://git.musl-libc.org/git/musl
add_remotes $1 ofono https://git.kernel.org/pub/scm/network/ofono/ofono.git
add_remotes $1 op-tee https://github.com/OP-TEE/optee_os.git
add_remotes $1 qemu https://gitlab.com/qemu-project/qemu.git
add_remotes $1 u-boot https://source.denx.de/u-boot/u-boot.git
add_remotes $1 uclibc-ng https://cgit.uclibc-ng.org/cgi/cgit/uclibc-ng.git
add_remotes $1 zephyr https://github.com/zephyrproject-rtos/zephyr
add_remotes $1 toybox https://github.com/landley/toybox.git
add_remotes $1 grub https://git.savannah.gnu.org/git/grub.git
add_remotes $1 bluez https://git.kernel.org/pub/scm/bluetooth/bluez.git
add_remotes $1 linux https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git \
                     https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git \
                     https://github.com/bootlin/linux-history.git
add_remotes $1 xen https://xenbits.xen.org/git-http/xen.git
add_remotes $1 freebsd https://git.freebsd.org/src.git

# Index all projects.
# Note: this is not only the above ones but all the ones in $1.
find $1 -mindepth 1 -maxdepth 1 -type d | \
while read dir; do
    do_index "$dir"
done
